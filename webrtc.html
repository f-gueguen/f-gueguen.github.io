<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Signaling</title>
</head>
<body>
    <h2>WebRTC Signaling</h2>
    <textarea id="localSessionDescription" readonly></textarea>
    <br/>
    <textarea id="remoteSessionDescription" placeholder="Paste remote session description here"></textarea>
    <br/>
    <button id="startButton">Start</button>
    <button id="submitButton">Submit Remote Desc.</button>
    <hr/>
    <h2>Status: <span id="status">Disconnected</span></h2>
    <h2>Chat</h2>
    <input id="messageInput" type="text" placeholder="Enter message">
    <button id="sendMessageButton">Send Message</button>
    <ul id="messages"></ul>

    <script>
        let localPeerConnection;
        let dataChannel;
        let iceCandidates = [];
        const startButton = document.getElementById('startButton');
        const submitButton = document.getElementById('submitButton');
        const localSessionDescriptionTextArea = document.getElementById('localSessionDescription');
        const remoteSessionDescriptionTextArea = document.getElementById('remoteSessionDescription');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessageButton');
        const messages = document.getElementById('messages');

        startButton.addEventListener('click', start);
        submitButton.addEventListener('click', submit);
        sendMessageButton.addEventListener('click', sendMessage);

        async function start() {
            localPeerConnection = new RTCPeerConnection();

            // Create a data channel
            dataChannel = localPeerConnection.createDataChannel("chat");
            setupDataChannel();

            localPeerConnection.onicecandidate = handleIceCandidate;
            localPeerConnection.oniceconnectionstatechange = handleConnectionChange;

            localPeerConnection.onicegatheringstatechange = async () => {
                if (localPeerConnection.iceGatheringState === 'complete') {
                    // Display the local description and ICE candidates to be copied by the other peer
                    localSessionDescriptionTextArea.value = JSON.stringify({
                        sdp: localPeerConnection.localDescription,
                        iceCandidates: iceCandidates
                    });
                }
            }

            const offer = await localPeerConnection.createOffer();
            await localPeerConnection.setLocalDescription(offer);
        }

        function handleIceCandidate(event) {
            console.log('icecandidate event:', event);
            if (event.candidate) {
                console.log('ICE candidate:\n' + event.candidate.candidate);
                iceCandidates.push(event.candidate);
            }
        }

        async function submit() {
            const sessionData = JSON.parse(remoteSessionDescriptionTextArea.value);
            const remoteDescription = new RTCSessionDescription(sessionData.sdp);
            const remoteIceCandidates = sessionData.iceCandidates;

            await localPeerConnection.setRemoteDescription(remoteDescription);
            console.log('Set remote description');
            remoteIceCandidates.forEach(candidate => {
                localPeerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            });

            if (remoteDescription.type === 'offer') {
                const answer = await localPeerConnection.createAnswer();
                await localPeerConnection.setLocalDescription(answer);

                localPeerConnection.onicegatheringstatechange = async () => {
                    if (localPeerConnection.iceGatheringState === 'complete') {
                        // Display the local answer to be copied by the other peer
                        localSessionDescriptionTextArea.value = JSON.stringify({
                            sdp: localPeerConnection.localDescription,
                            iceCandidates: iceCandidates
                        });
                    }
                }
            }
        }

        function sendMessage() {
            const message = messageInput.value;
            if (dataChannel.readyState === 'open') {
                dataChannel.send(message);
                addMessageToList('Sent: ' + message);
                messageInput.value = '';
            } else {
                console.log('Data channel is not open');
            }
        }

        function setupDataChannel() {
            dataChannel.onmessage = handleDataChannelMessage;
            dataChannel.onopen = handleDataChannelOpen;
            dataChannel.onclose = handleDataChannelClose;
        }

        function handleDataChannelMessage(event) {
            addMessageToList('Received: ' + event.data);
        }

        function handleDataChannelOpen() {
            addMessageToList('Data Channel Opened');
        }

        function handleDataChannelClose() {
            addMessageToList('Data Channel Closed');
        }

        function handleConnectionChange() {
            const state = localPeerConnection.iceConnectionState;
            const statusElement = document.getElementById('status');
            statusElement.textContent = capitalize(state);

            if (state === 'connected' || state === 'completed') {
                sendMessageButton.disabled = false;
            } else {
                sendMessageButton.disabled = true;
            }
        }

        function addMessageToList(message) {
            const li = document.createElement('li');
            li.textContent = message;
            messages.appendChild(li);
        }

        function capitalize(s) {
            if (typeof s !== 'string') return '';
            return s.charAt(0).toUpperCase() + s.slice(1);
        }

        function logError(error) {
            console.log(error.name + ': ' + error.message);
        }
    </script>
</body>
</html>
